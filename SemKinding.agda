module SemKinding where

open import Syntax
open import Kinding
open import BoolPoset
open import Relation.Binary
open import Data.Product
open import Level
open import Util using (l0;l1;l2)
open import Data.Unit renaming (preorder to unitPreorder ; decTotalOrder to unitToset )
open import Data.Nat as N
open import Data.Nat.Properties as NP
open import Data.Bool
open import Relation.Binary.PropositionalEquality as PE using (_≡_)
open Util

-- record SemPoset {ℓ₁} : Set (suc ℓ₁) where
--   field
--     -- An agda type which serves represents a λMC type 
--     A : Set 
--     -- A partial order on A
--     _⊑_ : Rel A ℓ₁    
--     -- Proof that it's actually a partial order
--     isPartialOrder : IsPartialOrder _⊑_ 

Preorder0 : Set₁
Preorder0 = Preorder l0 l0 l0

open Preorder

-- agda-mode: ⁎ is \asterisk, first choice
⟦_⁎⟧ : ∀ {τ : τ} → IsPoset τ → Preorder0
⟦ FunPoset {q = q} domIsProset codIsProset ⁎⟧ = 
  record{ 
    Carrier = D⇒C ;
    _≈_ = _≡_ ;
    _∼_ = _leq_ ;
    isPreorder = leqPreorder 
   }  
  where
    domProset : Preorder0
    domProset = ⟦ domIsProset ⁎⟧ 
    
    codProset : Preorder0
    codProset = ⟦ codIsProset ⁎⟧

    D : Set
    D = Carrier domProset
    _d≈_ : D → D → Set
    _d≈_ = _≈_ domProset
    _d≤_ : D → D → Set
    _d≤_ = _∼_ domProset
    
    C : Set
    C = Carrier codProset
    _c≈_ : C → C → Set
    _c≈_ = _≈_ codProset
    _c≤_ : C → C → Set
    _c≤_ = _∼_ codProset
    isPreorderCod : IsPreorder _c≈_ _c≤_
    isPreorderCod = isPreorder codProset
    
    D⇒C : Set
    D⇒C = Σ[ f ∈ (D → C) ] (∀{v₁ v₂ : D} → v₁ d≤ v₂ → (f v₁) c≤ (f v₂))
    
    _leq_ : D⇒C → D⇒C → Set
    (f , _) leq (g , _) = ∀{v : D} → (f v) c≤ (g v) 
    
    isRefl : _≡_ ⇒ _leq_
    isRefl {(f , _)} PE.refl {v} = reflexiveCod fv≈fv
      where
        reflexiveCod : _c≈_ ⇒ _c≤_
        reflexiveCod = IsPreorder.reflexive isPreorderCod
        
        isEq≈ : IsEquivalence _c≈_ 
        isEq≈ = IsPreorder.isEquivalence isPreorderCod
        
        fv≈fv : (f v) c≈ (f v)
        fv≈fv = IsEquivalence.refl isEq≈ {f v}

    leqTransitive : Transitive _leq_
    leqTransitive {(f , _)} {(g , _)} {(h , _)} f≤g g≤h {v} = trans≤ fv≤gv gv≤hv 
      where
        fv≤gv : (f v) c≤ (g v)
        fv≤gv = f≤g {v}

        gv≤hv : (g v) c≤ (h v)
        gv≤hv = g≤h {v}

        trans≤ : Transitive _c≤_
        trans≤ = IsPreorder.trans isPreorderCod
        
    leqPreorder : IsPreorder _≡_ _leq_
    leqPreorder = 
      record{
         isEquivalence = PE.isEquivalence ;
         reflexive =  isRefl ;
         trans = (λ {i} → λ {j} → λ {k} → leqTransitive {i} {j} {k}) 
       }


⟦ UnitPoset ⁎⟧ = unitPreorder
⟦ BoolPoset ⁎⟧ = B≤-preorder
⟦ NatPoset ⁎⟧ = NP.≤-preorder


StrictTotalOrder0 : Set₁
StrictTotalOrder0 = StrictTotalOrder l0 l0 l0

-- agda-mode: ⁑ is \asterisk, second choice
⟦_⁑⟧ : ∀ {τ : τ} → IsToset τ → StrictTotalOrder0
⟦ UnitToset ⁑⟧ = UnitStrictTotal.⊤-strictTotalOrder
⟦ NatToset ⁑⟧ = {!!}
⟦ BoolToset ⁑⟧ = {!!}
⟦ ProductToset isTosetL isTosetR ⁑⟧ = ×-strictTotalOrder ⟦ isTosetL ⁑⟧ ⟦ isTosetR ⁑⟧
  where
    open import Data.Product.Relation.Lex.Strict
⟦ SumToset isTosetL isTosetR ⁑⟧ = tosetLR
  where 
    open import Data.Sum.Relation.LeftOrder
    tosetLR : StrictTotalOrder0
    tosetLR = ⊎-<-strictTotalOrder {l0} {l0} {l0} {l0} {l0} {l0} ⟦ isTosetL ⁑⟧ ⟦ isTosetR ⁑⟧


open import Relation.Binary.Lattice

-- wait, tho, bounded join semilattice is not enough since it doesn't account for delta types
-- I need a few things to make this work:
--  1.) A way to generate free semilattices generated by posets
--     a) Delta types are not just partially ordered, but totally ordered
--     b) For non-forrest-of-chains deltas such as -^⊤, we must require that the deltas of a free
--        semilattice value are incomparable 
--  2.) A way to express semilattice homomorphisms
BoundedJoinSemilattice0 : Set₁
BoundedJoinSemilattice0 = BoundedJoinSemilattice l0 l0 l0

⟦_↩_⁂⟧ : ∀ {τ τ₀ : τ} → IsSemilat τ τ₀ → BoundedJoinSemilattice0 
⟦_↩_⁂⟧ = {!!}
